{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"main\", null, [/*#__PURE__*/_createElementVNode(\"div\", {\n  class: \"iblock\"\n}, [/*#__PURE__*/_createElementVNode(\"p\", null, [/*#__PURE__*/_createElementVNode(\"b\", null, \"Фреймворк\"), /*#__PURE__*/_createTextVNode(\" - это некая программная платформа, определяющая структуру программной системы; ПО (программное обеспечение), облегчающее разработку и объединяющее различные компоненты большого программного проекта.\")]), /*#__PURE__*/_createTextVNode(\" Употребляется также слово каркас (а некоторые авторы используют его в качестве основного) в том числе не базируясь вообще на англоязычном аналоге[1][2][3]. Можно также говорить о каркасном подходе[3] как о подходе к построению программ, где любая конфигурация программы строится из двух частей: Постоянная часть — каркас, не меняющийся от конфигурации к конфигурации и несущий в себе гнёзда, в которых размещается вторая, переменная часть; Сменные модули (или точки расширения). Отличие от библиотеки Фреймворк отличается от понятия библиотеки тем, что последняя может быть использована в программном продукте просто как набор подпрограмм похожей функциональности, не влияя на архитектуру программного продукта и не накладывая на неё никаких ограничений. В то время как фреймворк диктует правила построения архитектуры приложения, задавая на начальном этапе разработки поведение по умолчанию — «каркас», который нужно будет расширять и изменять согласно указанным требованиям. Пример программного фреймворка — C.M.F. (Content Management Framework), а пример библиотеки — модуль электронной почты. Также, в отличие от библиотеки, которая объединяет в себе набор близкой функциональности, — «фреймворк» может содержать в себе большое число разных по тематике библиотек. Ключевым отличием «фреймворка» от библиотеки является инверсия управления: пользовательский код вызывает функции библиотеки (или классы) и получает управление после вызова. Во «фреймворке» пользовательский код может реализовывать конкретное поведение, встраиваемое в более общий — «абстрактный» код фреймворка. При этом «фреймворк» вызывает функции (классы) пользовательского кода[4]. \"), /*#__PURE__*/_createElementVNode(\"p\", null, \"JavaScript-фреймворки являются неотъемлемой частью современной веб-разработки,предоставляя разработчикам проверенные и протестированные инструменты для создания масштабируемых и интерактивных веб-приложений. Многие современные компании используют фреймворки для своих решений, поэтому многие задачи связанные с разработкой клиентской части веб-приложений теперь требуют опыта работы с ними.\"), /*#__PURE__*/_createElementVNode(\"p\", null, \"Начинающему разработчику веб-интерфейсов может быть трудно понять с чего начать изучение фреймворков — их выбор разнообразен, а новые появляются постоянно. В основном же они работают аналогичным образом, но делают некоторые вещи по-разному, также есть некоторые специфичные вещи, которые следует соблюдать при использовании фреймворков.\"), /*#__PURE__*/_createElementVNode(\"p\", null, \"JavaScript-фреймворк — это фреймворк для приложений, написанный на языке программирования JavaScript. JavaScript-фреймворк отличается от Javascript-библиотеки потоком управления. Библиотека содержит функции для вызова родительским кодом, а фреймворк опирается на структуру приложения в целом.\"), /*#__PURE__*/_createTextVNode(\" Фреймворки JavaScript имеют ряд преимуществ, которые обеспечивают более эффективную и организованную разработку. — Ускорение разработки. Фреймворки предоставляют готовые решения для общих задач, таких как маршрутизация, управление состоянием и взаимодействие с сервером. Это позволяет разработчикам сосредоточиться на уникальных аспектах своего приложения, не тратя время на реализацию базовых функций. — Организация кода. Фреймворки обычно имеют структуру и рекомендации по организации кода, что способствует поддерживаемости и расширяемости приложений. Разработчики могут использовать заданную структуру для создания модульного и масштабируемого кода. — Поддержка сообщества. Популярные фреймворки имеют большие сообщества разработчиков, которые предлагают поддержку, обучение и ресурсы. Это облегчает поиск решений для проблем и ускоряет процесс разработки. \")])], -1 /* HOISTED */);\nexport function render(_ctx, _cache) {\n  const _component_PagetitleComponent = _resolveComponent(\"PagetitleComponent\");\n  return _openBlock(), _createElementBlock(_Fragment, null, [_createVNode(_component_PagetitleComponent, {\n    titleName: _ctx.areaName\n  }, null, 8 /* PROPS */, [\"titleName\"]), _hoisted_1], 64 /* STABLE_FRAGMENT */);\n}","map":{"version":3,"names":["_createElementVNode","class","_createTextVNode","_createElementBlock","_Fragment","_createVNode","_component_PagetitleComponent","titleName","_ctx","areaName","_hoisted_1"],"sources":["/home/kup/my_projects/vue/itdata/src/views/JsframeworksView/JsframeworksView.html"],"sourcesContent":["<PagetitleComponent :titleName=\"areaName\"/>\n<main>\n    <div class=\"iblock\">\n        <p><b>Фреймворк</b> - это некая программная платформа, определяющая структуру программной системы; ПО (программное обеспечение), облегчающее разработку и объединяющее различные компоненты большого программного проекта.</p>\n        \n\nУпотребляется также слово каркас (а некоторые авторы используют его в качестве основного) в том числе не базируясь вообще на англоязычном аналоге[1][2][3]. Можно также говорить о каркасном подходе[3] как о подходе к построению программ, где любая конфигурация программы строится из двух частей:\n\nПостоянная часть — каркас, не меняющийся от конфигурации к конфигурации и несущий в себе гнёзда, в которых размещается вторая, переменная часть;\nСменные модули (или точки расширения).\nОтличие от библиотеки\nФреймворк отличается от понятия библиотеки тем, что последняя может быть использована в программном продукте просто как набор подпрограмм похожей функциональности, не влияя на архитектуру программного продукта и не накладывая на неё никаких ограничений. В то время как фреймворк диктует правила построения архитектуры приложения, задавая на начальном этапе разработки поведение по умолчанию — «каркас», который нужно будет расширять и изменять согласно указанным требованиям. Пример программного фреймворка — C.M.F. (Content Management Framework), а пример библиотеки — модуль электронной почты.\n\nТакже, в отличие от библиотеки, которая объединяет в себе набор близкой функциональности, — «фреймворк» может содержать в себе большое число разных по тематике библиотек.\n\nКлючевым отличием «фреймворка» от библиотеки является инверсия управления: пользовательский код вызывает функции библиотеки (или классы) и получает управление после вызова. Во «фреймворке» пользовательский код может реализовывать конкретное поведение, встраиваемое в более общий — «абстрактный» код фреймворка. При этом «фреймворк» вызывает функции (классы) пользовательского кода[4].\n\n        <p>JavaScript-фреймворки являются неотъемлемой частью современной веб-разработки,предоставляя разработчикам проверенные и протестированные инструменты для создания масштабируемых и интерактивных веб-приложений. Многие современные компании используют фреймворки для своих решений, поэтому многие задачи связанные с разработкой клиентской части веб-приложений теперь требуют опыта работы с ними.</p>\n        <p>Начинающему разработчику веб-интерфейсов может быть трудно понять с чего начать изучение фреймворков — их выбор разнообразен, а новые появляются постоянно. В основном же они работают аналогичным образом, но делают некоторые вещи по-разному, также есть некоторые специфичные вещи, которые следует соблюдать при использовании фреймворков.</p>\n        <p>JavaScript-фреймворк — это фреймворк для приложений, написанный на языке программирования JavaScript. JavaScript-фреймворк отличается от Javascript-библиотеки потоком управления. Библиотека содержит функции для вызова родительским кодом, а фреймворк опирается на структуру приложения в целом.</p>\n        Фреймворки JavaScript имеют ряд преимуществ, которые обеспечивают более эффективную и организованную разработку. \n\n— Ускорение разработки. Фреймворки предоставляют готовые решения для общих задач, таких как маршрутизация, управление состоянием и взаимодействие с сервером. Это позволяет разработчикам сосредоточиться на уникальных аспектах своего приложения, не тратя время на реализацию базовых функций.\n\n— Организация кода. Фреймворки обычно имеют структуру и рекомендации по организации кода, что способствует поддерживаемости и расширяемости приложений. Разработчики могут использовать заданную структуру для создания модульного и масштабируемого кода.\n\n— Поддержка сообщества. Популярные фреймворки имеют большие сообщества разработчиков, которые предлагают поддержку, обучение и ресурсы. Это облегчает поиск решений для проблем и ускоряет процесс разработки.\n    </div>\n</main>"],"mappings":";gCACAA,mBAAA,CA2BO,e,aA1BHA,mBAAA,CAyBM;EAzBDC,KAAK,EAAC;AAAQ,I,aACfD,mBAAA,CAA8N,Y,aAA3NA,mBAAA,CAAgB,WAAb,WAAS,G,aAHvBE,gBAAA,CAG2B,yMAAuM,E,gBAHlOA,gBAAA,CAGsO,wnDAc9N,G,aAAAF,mBAAA,CAA6Y,WAA1Y,wYAAsY,G,aACzYA,mBAAA,CAAuV,WAApV,kVAAgV,G,aACnVA,mBAAA,CAA2S,WAAxS,sSAAoS,G,aAnB/SE,gBAAA,CAmBmT,g2BAQ/S,E;;;uBA3BJC,mBAAA,CAAAC,SAAA,SAAAC,YAAA,CAA2CC,6BAAA;IAAtBC,SAAS,EAAEC,IAAA,CAAAC;EAAQ,wCACxCC,UA2BO,C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}